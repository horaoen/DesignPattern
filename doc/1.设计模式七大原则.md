[toc]

# 开闭原则

- 定义：**一个软件实体如类、模块和函数应该对扩展开放，对修改关闭**。
- 用抽象构建框架，用实现扩展细节。
- 优点：提高软件系统的可复用性及可维护性。

![2](https://gitee.com/horaoen/blogImage/raw/master/img/2.png)

```c#
using System;

namespace DesignPattern.Principle.OpenClose;
internal interface ICourse
{
    int Id { get; set; }
    String Name { get; set; }
    double Price { get; set; }
}
```

```c#

namespace DesignPattern.Principle.OpenClose;

public class JavaCourse : ICourse
{
    public int Id { get; set; }
    public string Name { get; set; }
    public double Price { get; set; }

    public JavaCourse(int id, string name, double price)
    {
        Id = id;
        Name = name;
        Price = price;
    }
}

```

```c#
namespace DesignPattern.Principle.OpenClose;
public class JavaDiscountCourse : JavaCourse
{
    private double _price;
    public new double Price
    {
        get => _price;
        set => _price = value * 0.8;
    }

    public JavaDiscountCourse(int id, string name, double price) : base(id, name, price)
    {
        Price = price;
    }
}
```

```c#
using DesignPattern.Principle.OpenClose;
using Xunit;

namespace Tests.Principle;
public class OpenCloseTest
{
    [Fact]
    public void DiscountPrice()
    {
        //Arrange
        var mockJavaDiscountCourse = new JavaDiscountCourse(1, "大话设计模式", 20.0);
        double discountPrice = 20 * 0.8;
        
        //Assert
        Assert.Equal(discountPrice, mockJavaDiscountCourse.Price);
    }
}
```



# 依赖倒置原则

- 定义：**高层模块不应该依赖底层模块，二者都应该依赖其抽象。**
- 抽象不应该依赖细节，细节应该依赖抽象。
- 针对接口编程，不要针对实现编程。
- 优点：可以减少类间的代码耦合性、提高系统稳定性，提高代码可读性和可维护性，可降低修改程序所造成的风险。

![Type Dependencies Diagram for Person and other elements](https://gitee.com/horaoen/blogImage/raw/master/img/Type%20Dependencies%20Diagram%20for%20Person%20and%20other%20elements.png)

```c#
namespace DesignPattern.Principle.DependenceInversion;
public interface ICourse
{
    string StudyCourse();
}
```

```c#
namespace DesignPattern.Principle.DependenceInversion
{
    public class JavaCourse : ICourse
    {
        public string StudyCourse()
        {
            return "学Java";
        }
    }
}
```

```c#
namespace DesignPattern.Principle.DependenceInversion
{
    public class CSharpCourse : ICourse
    {
        public string StudyCourse()
        {
            return "学C#";
        }
    }
}

```

```c#
using System;

namespace DesignPattern.Principle.DependenceInversion;
public class Person
{
    //public void StudyJavaCourse()
    //{
    //    return "学Java";
    //}

    //public void StudyCSharpCourse()
    //{
    //    return "学C#";
    //}

    public string StudyCourse(ICourse course)
    {
        return course.StudyCourse();
    }
}
```

```c#
using DesignPattern.Principle.DependenceInversion;
using Xunit;

namespace Tests.Principle;
public class DependenceInversionTest
{
    [Fact]
    public void StudyJavaCourse()
    {
        //Arrange
        var stuJavaCourse = new JavaCourse();
        var mockPerson = new Person();

        //Act
        var expected = "学Java";
        var actual = mockPerson.StudyCourse(stuJavaCourse);
        //Assert 
        Assert.Equal(expected, actual);
    }

    [Fact]
    public void StudyCSharpCourse()
    {
        //Arrange
        var studyCSharpCourse = new CSharpCourse();
        var mockPerson = new Person();

        //Act
        var expected = "学C#";
        var actual = mockPerson.StudyCourse(studyCSharpCourse);

        Assert.Equal(expected, actual);
    }
}
```

# 单一职责原则

- 定义：不要存在多于一个导致类变更的原因
- 一个类/接口/方法只负责一项职责
- 优点：降低类的复杂度、提高类的可读性，提高系统的可维护性、降低变更引起的风险

![1](https://gitee.com/horaoen/blogImage/raw/master/img/1.png)

```c#

namespace DesignPattern.Principle.SingleResponsibility
{
    public interface IBird
    {
        string MainMoveMode();
    }
}

namespace DesignPattern.Principle.SingleResponsibility
{
    public class FlyBird : IBird
    {
        public string MainMoveMode()
        {
            return "翅膀";
        }
    }
}

//////////////////////////////////////////////////////////
namespace DesignPattern.Principle.SingleResponsibility
{
    public class WalkBird : IBird
    {
        public string MainMoveMode()
        {
            return "脚";
        }
    }
}
//////////////////////////////////////////////////////////
using DesignPattern.Principle.SingleResponsibility;
using Xunit;

namespace Tests.Principle
{
    public class SingleResponsibilityTest
    {
        [Fact]
        public void SingleResponsibilityOfClass()
        {
            //Arrange
            var mockFlyBird = new FlyBird();
            var mockWalkBird = new WalkBird();

            //Act 
            var expectedFlyBird = "翅膀";
            var expectedWalkBird = "脚";

            //Assert
            Assert.Equal(expectedFlyBird, mockFlyBird.MainMoveMode());
            Assert.Equal(expectedWalkBird, mockWalkBird.MainMoveMode());
        }
    }
}
```

```c#
using System;

namespace DesignPattern.Principle.SingleResponsibility
{
    public class Method
    {
        public string UserName { get; set; }
        public string Address { get; set; }

        public Method(string userName, String address)
        {
            UserName = userName;
            Address = address;
        }
        //public void UpdateUserInfo(string userName, string address)
        //{
        //    UserName = userName;
        //    Address = address;
        //}

        public void UpdateUserName(string userName)
        {
            UserName = userName;
        }

        public void UpdateAddress(string address)
        {
            Address = address;
        }
    }
}

```

# 接口隔离原则

- 定义：用多个专门的接口，而不是用单一的总接，客户端不应该依赖它不需要的接口。
- 一个类对一个类的依赖应该建立在最小的接口上。
- 建立单一接口，不要使用庞大臃肿的接口。
- 尽量细化接口，接口中的方法尽量少。
- 注意适度原则，一点要适度。
- 优点：符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性。

![9](https://gitee.com/horaoen/blogImage/raw/master/img/9.png)

```c#
namespace DesignPattern.Principle.InterfaceSegregation
{
    public interface IAnimalAction
    {
        void Eat();
        void Fly();
        void Swim();
    }
}
//不应该设计的接口
```

```c#

namespace DesignPattern.Principle.InterfaceSegregation
{
    internal interface IEatAnimalAction
    {
        void Eat();
    }
}
/////////////////////////////////////////////////
namespace DesignPattern.Principle.InterfaceSegregation
{
    internal interface IFlyAnimalAction
    {
        void Fly();
    }
}

/////////////////////////////////////////////////
namespace DesignPattern.Principle.InterfaceSegregation
{
    internal interface ISwimAnimalAction
    {
        void Swim();
    }
}
//////////////////////////////////////////////////
using System;

namespace DesignPattern.Principle.InterfaceSegregation
{
    internal class Dog : IEatAnimalAction, ISwimAnimalAction
    {
        public void Eat()
        {
            throw new NotImplementedException();
        }

        public void Swim()
        {
            throw new NotImplementedException();
        }
    }
}
```

# 迪米特原则

- 定义：一个对象应该对其他对象保持最少的了解，又叫最少知道原则。
- 尽量降低类与类之间的耦合
- 优点：降低类之间的耦合
- 强调只和朋友交流，不和陌生人说话
- 朋友：出现在成员变量、方法的输入、输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类。

![demeter](https://gitee.com/horaoen/blogImage/raw/master/img/demeter.png)

```c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DesignPattern.Principle.Demeter
{
    public class Course
    {
    }
}
////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DesignPattern.Principle.Demeter
{
    public class TeamLeader
    {
        public List<Course> Courses { get; set; }

        public TeamLeader(int courseNum)
        {
            Courses = new List<Course>();
            for (int i = 0; i < courseNum; i++)
            {
                Courses.Add(new Course());
            }
        }

        public int CheckNumberOfCourse()
        {
            return Courses.Count;
        }
    }
}
/////////////////////////////////////////
using System.Collections.Generic;

namespace DesignPattern.Principle.Demeter
{
    public class Boss
    {
        public int CommandCheckNumber(TeamLeader leader)
        {
            return leader.CheckNumberOfCourse();
        }
    }
}

```

```c#
using DesignPattern.Principle.Demeter;
using Xunit;

namespace Tests.Principle
{
    public class DemeterTest
    {
        [Fact]
        public void CommandCheckNumber()
        {
            //Arrange 
            var mockBoss = new Boss();
            var courseNum = 20;
            var stuTeamLeader = new TeamLeader(courseNum);

            //Act
            var expected = courseNum;
            var actual = mockBoss.CommandCheckNumber(stuTeamLeader);

            //Assert
            Assert.Equal(expected, actual);
        }
    }
}

```

